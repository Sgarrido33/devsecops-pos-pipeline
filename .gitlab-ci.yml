image: docker:latest

services:
  - docker:dind

variables:
  AUTO_DEVOPS_ENABLED: "false"
  # Ajusta tu usuario aquÃ­ o en las variables de GitLab
  IMAGE_TAG: "$DOCKER_USER/proyecto-devsecops:latest"

stages:
  - validate-structure
  - test-backend
  - build-backend
  - Secret-Scanning-IAC
  - IAC-Scanning-Checkov
  - SCA(trivy)
  - SAST(Semgrep)
  - DAST(OWASP)
  - deploy

# =====================================================
# 1. VALIDATE STRUCTURE (Backend & Frontend)
# =====================================================
validate_structure:
  stage: validate-structure
  image: alpine:latest
  script:
    - echo "ðŸ” Verificando estructura del proyecto..."
    # Verificamos que existan las carpetas clave
    - "if [ ! -d backend ]; then echo âŒ Falta carpeta backend; exit 1; fi"
    - "if [ ! -d nginx ]; then echo âŒ Falta carpeta nginx; exit 1; fi"
    - "if [ ! -f Dockerfile ]; then echo âŒ Falta Dockerfile en raÃ­z; exit 1; fi"
    - echo "âœ… Estructura base correcta."

# =====================================================
# 2. TEST BACKEND (Unit Tests)
# =====================================================
unit_tests_backend:
  stage: test-backend
  image: python:3.10-slim
  services:
    - name: mysql:5.7
      alias: mysql
  variables:
    MYSQL_HOST: "mysql"
    MYSQL_USER: "test_user"
    MYSQL_PASSWORD: "test_password"
    MYSQL_DATABASE: "test_db"
    MYSQL_ROOT_PASSWORD: "root_password" 
  script:
    - echo "ðŸ§ª Ejecutando pruebas unitarias del Backend..."
    - cd backend
    - pip install -r requirements.txt
    - pip install pytest cryptography
    # Ejecutamos los tests. PYTHONPATH asegura que Python encuentre los mÃ³dulos
    - export PYTHONPATH=.
    - pytest tests/ --junitxml=../report.xml
  artifacts:
    when: always
    reports:
      junit: report.xml

# =====================================================
# 3. BUILD BACKEND (Dry Run)
# =====================================================
build_image_dry_run:
  stage: build-backend
  script:
    - echo "ðŸ³ Verificando construcciÃ³n de la imagen (Backend)..."
    # Asumimos que el Dockerfile de la raÃ­z es para la App Python
    - docker build -t test-backend .
    - echo "âœ… Build exitoso."

# =====================================================
# 4. SECRET SCANNING (IAC + REPO)
# =====================================================
scan_secrets_gitleaks:
  stage: Secret-Scanning-IAC
  image:
    name: zricethezav/gitleaks:latest
    entrypoint: [""]
  script:
    - "gitleaks detect --source=. -v --report-path gitleaks-report.json"
  allow_failure: true
  artifacts:
    paths: [gitleaks-report.json]

scan_secrets_trufflehog:
  stage: Secret-Scanning-IAC
  image: ubuntu:22.04
  before_script:
    - apt-get update -y && apt-get install -y git curl jq
  script:
    - curl -sSfL https://raw.githubusercontent.com/trufflesecurity/trufflehog/main/scripts/install.sh | sh -s -- -b .
    # Escaneamos todo el sistema de archivos actual
    - "./trufflehog filesystem . --results=verified,unknown --json > trufflehog-report.json || true"
  allow_failure: true
  artifacts:
    paths: [trufflehog-report.json]

# =====================================================
# 5. IAC SCANNING (CHECKOV)
# =====================================================
iac_scan_checkov:
  stage: IAC-Scanning-Checkov
  image:
    name: bridgecrew/checkov:latest
    entrypoint: [""]
  script:
    # Escanea el Dockerfile raÃ­z y configs de Nginx si las detecta
    - "checkov -d . --check CKV_DOCKER_*,CKV_NGINX_* -o json > checkov-report.json || true"
    - cat checkov-report.json
  allow_failure: true
  artifacts:
    paths: [checkov-report.json]

# =====================================================
# 6. SCA (TRIVY)
# =====================================================
sca_trivy_scan:
  stage: SCA(trivy)
  image:
    name: aquasec/trivy:latest
    entrypoint: [""]
  script:
    - "trivy fs . --format json --output trivy-report.json"
  allow_failure: true
  artifacts:
    paths: [trivy-report.json]

# =====================================================
# 7. SAST (SEMGREP)
# =====================================================
sast_semgrep_scan:
  stage: SAST(Semgrep)
  image:
    name: returntocorp/semgrep:latest
    entrypoint: [""]
  script:
    - rm -rf /src 2>/dev/null || true
    - ln -s $CI_PROJECT_DIR /src
    - "semgrep scan --config=auto --json --output=semgrep-report.json ."
  allow_failure: true
  artifacts:
    paths: [semgrep-report.json]

# =====================================================
# 8. DAST (OWASP ZAP) - PRODUCCION (NGINX + GUNICORN)
# =====================================================
dast_owasp_zap:
  stage: DAST(OWASP)
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_NETWORK: "app-net"
  script:
    - echo "ðŸš€ Iniciando entorno DAST Simulando ProducciÃ³n..."
    - docker network create $DOCKER_NETWORK
    
    # 1. Levantar BACKEND (Python + Gunicorn)
    # Importante: Nombre 'web' para que Nginx lo encuentre
    - |
      docker run -d --name web --network $DOCKER_NETWORK \
      -v $PWD/backend:/app -w /app \
      python:3.10-slim \
      sh -c "pip install -r requirements.txt && pip install gunicorn && gunicorn -w 4 -b 0.0.0.0:5000 wsgi:app"
    - sleep 10 # Damos tiempo a Gunicorn para arrancar

    # 2. Levantar NGINX (Reverse Proxy)
    - |
      docker run -d --name nginx-proxy --network $DOCKER_NETWORK \
      -p 80:80 \
      -v $PWD/nginx/nginx.conf:/etc/nginx/conf.d/default.conf \
      nginx:latest
    - sleep 5
    
    # 3. ATACAR A NGINX (Puerto 80)
    - echo "ðŸ”¥ Atacando Nginx con OWASP ZAP..."
    - |
      docker run --rm --network $DOCKER_NETWORK \
      -v $PWD:/zap/wrk:rw \
      zaproxy/zap-stable \
      zap-baseline.py \
      -t http://nginx-proxy \
      -r zap-nginx-report.html || true
      
    # Limpieza
    - docker rm -f nginx-proxy web
    - docker network rm $DOCKER_NETWORK
  artifacts:
    when: always
    paths:
      - zap-nginx-report.html
    expire_in: 1 week

# =====================================================
# 9. DEPLOY TO DOCKERHUB
# =====================================================
deploy_to_dockerhub:
  stage: deploy
  image: docker:latest
  services:
    - docker:dind
  script:
    - echo "ðŸšš Desplegando imagen a Docker Hub..."
    - docker login -u "$DOCKER_USER" -p "$DOCKER_PASS"
    # Construimos y subimos la imagen de la AplicaciÃ³n
    - docker build -t $IMAGE_TAG .
    - docker push $IMAGE_TAG
    - "echo âœ… Imagen publicada: $IMAGE_TAG"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"